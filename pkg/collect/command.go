// SPDX-FileCopyrightText: 2022 SAP SE or an SAP affiliate company and Gardener contributors
//
// SPDX-License-Identifier: Apache-2.0

package collect

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path"

	"github.com/gardener/network-problem-detector/pkg/agent/db"
	"github.com/gardener/network-problem-detector/pkg/common"

	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type collectCommand struct {
	common.ClientsetBase
	directory string
}

func CreateCollectCmd() *cobra.Command {
	cc := &collectCommand{}
	cmd := &cobra.Command{
		Use:   "collect",
		Short: "collect observations from all nodes",
		Long:  `collect observations generated by both node and pod daemonsets using 'kubectl exec' and 'tar'`,
		RunE:  cc.collect,
	}
	cc.AddKubeConfigFlag(cmd.Flags())
	cmd.Flags().StringVar(&cc.directory, "output", "collected-observations", "database directory to store the collected observations.")

	return cmd
}

func (cc *collectCommand) collect(cmd *cobra.Command, args []string) error {
	log := logrus.WithField("cmd", "collect")

	if err := os.MkdirAll(cc.directory, 0755); err != nil {
		return err
	}

	if err := cc.SetupClientSet(); err != nil {
		return err
	}

	ctx := context.Background()
	list, err := cc.Clientset.CoreV1().Pods(common.NamespaceKubeSystem).List(ctx, metav1.ListOptions{
		LabelSelector: fmt.Sprintf("%s=%s", common.LabelKeyK8sApp, common.NameDaemonSetAgentHostNet),
	})
	if err != nil {
		return fmt.Errorf("listing pods failed: %w", err)
	}

	dir, err := ioutil.TempDir("", "nwpd-collect-")
	if err != nil {
		return fmt.Errorf("creating temporary directory failed: %w", err)
	}
	defer os.RemoveAll(dir)

	kubeconfigOpt := ""
	if cc.Kubeconfig != "" {
		kubeconfigOpt = " --kubeconfig=" + cc.Kubeconfig
	}
	totalBytes := 0
	totalFiles := 0
	for _, item := range list.Items {
		log.Infof("Loading observations from %s", item.Name)
		cmdline := fmt.Sprintf("kubectl %s -n %s exec %s -- tar cfz - -C %s . | tar xfz - -C %s", kubeconfigOpt, item.Namespace, item.Name, common.PathOutputDir, dir)
		var stderr bytes.Buffer
		cmd := exec.Command("sh", "-c", cmdline)
		cmd.Stderr = &stderr
		cmd.Env = os.Environ()
		err = cmd.Run()
		if err != nil {
			log.Errorf("kubectl exec failed for %s/%s: %s (stderr: %s)", item.Namespace, item.Name, err, stderr.String())
			continue
			//return fmt.Errorf("kubectl exec failed for %s/%s: %s (stderr: %s)", item.Namespace, item.Name, err, stderr.String())
		}
		filenames, err := db.GetAnyRecordFiles(dir, false)
		if err != nil {
			return fmt.Errorf("listing temp dir %s failed: %s", dir, err)
		}
		if len(filenames) == 0 && stderr.Len() != 0 {
			return fmt.Errorf("execution with unexpected result: %s", stderr.String())
		}

		outdir := path.Join(cc.directory, item.Spec.NodeName)
		if err := os.MkdirAll(outdir, 0755); err != nil {
			return err
		}
		countBytes := 0
		countFiles := 0
		for _, filename := range filenames {
			_, name := path.Split(filename)
			destFilename := path.Join(outdir, name)
			n, err := copyFile(filename, destFilename)
			if err != nil {
				return err
			}
			err = copyFileDates(filename, destFilename)
			if err != nil {
				return err
			}
			countBytes += int(n)
			countFiles++

		}
		log.Infof("Loaded %d bytes from %d files", countBytes, countFiles)
		totalBytes += countBytes
		totalFiles += countFiles
	}
	log.Infof("Written %d bytes form %d files to directory %s", totalBytes, totalFiles, cc.directory)

	return nil
}

func copyFile(srcFilename, destFilename string) (int64, error) {
	input, err := os.Open(srcFilename)
	if err != nil {
		return 0, err
	}
	defer input.Close()

	output, err := os.Create(destFilename)
	if err != nil {
		return 0, err
	}
	defer output.Close()

	return io.Copy(output, input)
}

func copyFileDates(srcFilename, destFilename string) error {
	stat, err := os.Stat(srcFilename)
	if err != nil {
		return err
	}
	return os.Chtimes(destFilename, stat.ModTime(), stat.ModTime())
}
